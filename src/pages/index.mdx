import Layout from "../layout";

import calldata from "../img/calldata.svg";
import generic_contract from "../img/generic_contract.svg";
import generic_data from "../img/generic_data.svg";
import issues_table from "../img/issues_table.svg";
import metadata_inheritence from "../img/metadata_inheritence.svg";
import minter_inheritence from "../img/minter_inheritence.svg";
import placeholder from "../img/placeholder.svg";
import return_data from "../img/return_data.svg";
import risk_model from "../img/risk_model.svg";
import storage_layout from "../img/storage_layout.svg";
import teleporter_inheritence from "../img/teleporter_inheritence.svg";
import token_lifecycle from "../img/token_lifecycle.svg";
import token_supply_chart from "../img/token_supply_chart.svg";
import token_supply_tree from "../img/token_supply_tree.svg";
import token from "../img/token.svg";
import role_chart from "../img/role_chart.svg";

export default Layout;

# Avastars Smart Contract Audit Report

v0.3.0<br />
24 March 2020<br />
[@nicholashc](https://github.com/nicholashc)<br />

---

<br />
<br />
<br />
\_note placeholders images\_
<br />
<img src={generic_contract} width="300" alt="generic_contract" />
<img src={generic_data} width="1200" alt="generic_data" />

## Introduction

_note placeholder words for introduction..._

### Objectives

_note revise this content and reformat for public audience..._

The goal of this audit is to analyze the smart contracts for security vulnerabilities, uncover unintended behaviour, and anticipate potential risks that could exist in an adversarial production environment. The report identifies specific security issues and offers actionable recommendations categorized by Risk Level. It also analyzes the design and implementation of the project as a whole, including the contract architecture, trust model, and game theoretic threats. Finally, the report considers how the complexity of the contracts, test coverage, documentation, and quality of the code base impact the security of the application.

### Scope and Timeline

In the week since receiving the audit report, the Avastars team has worked diligently to address the issues in the code base. This report updates the status of any outstanding items and considers the effectiveness of the remediations. It also adds recommendations, clarifications, and/or corrections where required.

This update considers all changes to the smart contract code up to commit [b2ac915](https://github.com/Dapp-Wizards/Avastars-Contracts/commit/b2ac9159a034c27b3ccad98fa806af08be37a842). Please note that this is not a comprehensive re-audit. This effort is limited to a brief manual review of the highest priority issues and modified sections of code.

The revisions successfully addressed the most serious security issues. Many of the lower priority recommendations were also incorporated. I have reviewed each issue with the Avastars team and discussed the solutions. In some cases, the team acknowledged an issue but decided that the best course of action was not to change the contracts directly. In other cases, the team carefully considered whether the security concerns and/or design tradeoffs fell within an acceptable range of operational risk.

This report contains the results from the security audit of the Avastars smart contract code base. The code reviewed includes the Solidity smart contracts from PR#1 [b8220ee](https://github.com/Dapp-Wizards/Avastars-Contracts/commit/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc) on the master branch of the [Avastars-Contracts](https://github.com/Dapp-Wizards/Avastars-Contracts/) repo. A complete list of the files reviewed is available in the [Appendix](#a01-smart-contracts-reviewed).

It also includes an updated analysis of four issues from the [1ea95a9](https://github.com/Dapp-Wizards/Avastars-Contracts/commit/1ea95a92d0859610533f40acd1df68a91353c0ea) commit. These issues were a part of the Preliminary Report delivered on 12/01/20.

See [Version History](#) for more information.

## Project Overview

### Contract Architecture

Once live, the Avastars contracts will live at 4 addresses. These are made up of 17 core Avastars contracts, including 2 interfaces. In addition, the code base inherits 5 contracts, 4 libraries, and 5 interfaces from the OpenZeppelin smart contract repository. All four contracts have the ability to be paused and upgraded by a permissioned administrator.

##### AvastarTeleporter

This contract manages the Avastar, Prime, and Replicant tokens. It holds the token state, mints new tokens, manages ERC-721 functionality, and stores trait and attribution information. AvastarTeleporter is not designed to receive ether.

The current AvastarTeleporter mainnet contract is located at [0xF3E778F839934fC819cFA1040AabaCeCBA01e049](https://etherscan.io/address/0xf3e778f839934fc819cfa1040aabacecba01e049#code).

<img src={teleporter_inheritence} width="1200" alt="teleporter_inheritence" />

| Address                                                                                | Permissions  | Notes                       |
| :------------------------------------------------------------------------------------- | :----------- | :-------------------------- |
| [0xeff045...](https://etherscan.io/address/0xeff045036321258117FF9cF15f67Ac22a51c01D9) | admin        | deployer, EOA               |
| [0x4C7BEd...](https://etherscan.io/address/0x4C7BEdfA26C744e6bd61CBdF86F3fc4a76DCa073) | admin, owner | EOA                         |
| [0xE31763...](https://etherscan.io/address/0xE31763aaD9294f073DDF18B36503ed037ae5e737) | minter       | AvastarPrimeMinter contract |
| [0xb60dfb...](https://etherscan.io/address/0xb60dfb4F11B38990911E8F8569B8b72DdBFB0411) | minter       | EOA                         |

\*EOA = Externally-owned account (non-contract)

##### AvastarMetadata

This contract assembles the artwork and metadata associated with the tokens. It calls the AvastarTeleporter to read from its state. AvastarMetadata is not designed to receive ether or handle ERC-721 tokens.

The current AvastarMetadata mainnet contract is located at [0xE895B49900636F0330c3dc2Fb6FA09d234622E8e](https://etherscan.io/address/0xe895b49900636f0330c3dc2fb6fa09d234622e8e#code).

<img src={metadata_inheritence} width="1200" alt="metadata_inheritence" />

| Address                                                                                | Permissions  | Notes         |
| :------------------------------------------------------------------------------------- | :----------- | :------------ |
| [0xeff045...](https://etherscan.io/address/0xeff045036321258117FF9cF15f67Ac22a51c01D9) | admin        | deployer, EOA |
| [0x4C7BEd...](https://etherscan.io/address/0x4C7BEdfA26C744e6bd61CBdF86F3fc4a76DCa073) | admin, owner | EOA           |

##### AvastarPrimeMinter

This contract accepts deposits from users who wish to purchase Primes. When triggered by a permissioned minter transaction, it initiates the minting of new Prime tokens by calling the AvastarTeleporter. AvastarPrimeMinter has the ability to both send and receive ether. It is not designed to receive ERC-721 tokens.

The current AvastarPrimeMinter mainnet contract is located at [0xE31763aaD9294f073DDF18B36503ed037ae5e737](https://etherscan.io/address/0xe31763aad9294f073ddf18b36503ed037ae5e737#code).

<img src={minter_inheritence} width="1200" alt="minter_inheritence" />

| Address                                                                                | Permissions  | Notes         |
| :------------------------------------------------------------------------------------- | :----------- | :------------ |
| [0xeff045...](https://etherscan.io/address/0xeff045036321258117FF9cF15f67Ac22a51c01D9) | admin        | deployer, EOA |
| [0x4C7BEd...](https://etherscan.io/address/0x4C7BEdfA26C744e6bd61CBdF86F3fc4a76DCa073) | admin, owner | EOA           |
| [0xb60dfb...](https://etherscan.io/address/0xb60dfb4F11B38990911E8F8569B8b72DdBFB0411) | minter       | EOA           |
| [0xF3d450...](https://etherscan.io/address/0xF3d4508ee61FF93B83dEE4f7ACEdfd82A8b18184) | minter       | no tx history |
| [0x6ca2E2...](https://etherscan.io/address/0x6ca2E2Fabb61017706c2D796eE3AC3258441C3fe) | minter       | no tx history |
| [0x7A8C27...](https://etherscan.io/address/0x7A8C27f71641Df9F0b86bf1280D66B3C2d92096A) | minter       | no tx history |
| [0x56bCBC...](https://etherscan.io/address/0x56bCBCc51489fe9fAaAFbBE81177A03aD413cD3d) | minter       | no tx history |
| [0xF7e85F...](https://etherscan.io/address/0xF7e85F15462Ced330463030f340018ea1Ea03b36) | minter       | no tx history |
| [0xb3e1d8...](https://etherscan.io/address/0xb3e1d813487aFfBCF327C5FB4DA1Ae29584B7FC3) | minter       | no tx history |
| [0xF15DE3...](https://etherscan.io/address/0xF15DE3db897050c5B641290E090E1f6106791DE1) | minter       | no tx history |

##### AvastarReplicantMinter

This contract is still in development, but has much of the same functionality as AvastarPrimeMinter.

### Token Design

Avastars tokens are ERC-721 compliant non-fungible tokens. An Avastar can be part one of two waves: Prime or Replicant. Primes are minted within unique genes and traits. Replicants recombine these traits in a 2nd wave. In addition, each Avastar has a gender, genome, and rarity level. These combine to give the Avastar a distinct set of visual traits from an enormous set of possibilities. The associated artwork and metadata is stored on-chain as svg layers.

Replicants are produced from Primes by recombining Traits. The supply of Replicants is not specified in the contracts but is designed to never surpass the supply of Primes.

Users can mint Primes by depositing funds in the smart contract. An admin account then sends a 2nd callback transaction with the genome, traits, and other features as calldata. The transaction accounts for the user's funds in escrow and mints the corresponding token.

### Token Supply

<img src={token_supply_tree} width="1200" alt="token_supply_tree" />

| Legend |
| :----- |
| S0     | Promo season number |
| S1-5   | Season number |
| G1-5   | Generation number |
| P      | Primes, including Promos |
| R      | Replicants |

- Generations: 5
- Series: 5 per generation, plus promos
- Promo Primes per generation: 200
- Primes per series: 5,000
- 25,200 Primes per generation and 126,000 all time across the 5 generations
- 25,200 Replicants per generation and 126,000 all time across the 5 generations
- There can be maximum of 252,000 total Avastars

<img src={token_lifecycle} width="1200" alt="token_lifecycle" />

### Trust Model, Access, and Authority

All contracts define the same three permissioned roles. However, these are set independently in each contract and the addresses holding a role in one contract do not necessarily hold it in another. Multiple addresses can hold the same role in a given contract. The same address can hold multiple permissioned roles in the same or across contracts. Once assigned, a role cannot be taken away.

##### onlySysAdmin

The admin role has the highest level of permissions. It can assign any other role, pause and unpause, upgrade the contract, and set other permissioned state variables.

##### onlyMinter

The minter role has access to minting new Prime and Replicant tokens. In order for users to make purchases, the AvastarPrimeMinter and AvastarReplicantMinter contracts must hold the minter role in the AvastarTeleporter contract.

##### onlyOwner

The owner role controls the ability to view and withdraw ether from the sale of Primes and Replicants in the two Minter contracts.

<img src={role_chart} width="500" alt="role_chart" />

### Documentation, Code Quality, and Testing

The project is throughly and consistently documented. The code comments are rigorous and clearly explain technical decisions. The truffle project is well-organized. The high-level design decisions are explicit. The caliber of the Avastars documentation will be a huge asset in moving smoothly through the audit process.The smart contracts are accompanied by suite of 105 unit tests (all passing) as well as gas estimates for each function call. This has since been updated to ... tests

### Security Considerations

Based on the initially assessment of the smart contract architecture, the following areas will receive particular attention during the full audit:

- input validation and type safety
- minting, transferring, and approving access to tokens and traits ether deposits and withdraws
- contract set up, upgradability, and interdependency
- data validation during external calls and interface checks admin permissions
- internal accounting and token supply
- race conditions and denial of service vectors

## Key Observations

### Summary of Issues

<img src={issues_table} width="1200" alt="issues_table" />
<br />

### General Assessment

_note update to be in present tense..._

- 50 issues of varying severity were identified during the audit (including 4 previously catalogued in the 12/01/20 Preliminary Assessment) (one removed)
- The vast majority of issues are relatively minor in nature. Many of the High and Medium severity issues can be fixed will minimal changes to the code base
- The code quality, test suite, and project documentation is of a consistently high caliber
- The contract architecture attempts to minimize potential attack surfaces as much as possible. For example, there is only a single payable function in the entire project and only two functions designed to withdraw ether
- The contracts use complex and state-intensive data structures to manage tokens. A number of the more serious vulnerabilities come from type or validation issues or unexpected state access
- The contracts rely heavily on malleable properties like array lengths to keep track of critical global state values
- The Avastars team has stated that optimizing gas costs is not the highest priority. They are paying the cost of loading large amounts of state into the contracts as well as minting tokens on behalf of users
- Privileged access and permissions allow administrators to manage token minting, collect ether, and configure the contracts
- This trust model allows the administrators to manage a number of operational tasks such as setting prices, generating hashes, and managing the minting process off chain
- Maintaining this level of control was a conscious design decision. However, it comes with the trade off of requiring that users trust the project's administrators
- The application requires ongoing actions from the administrators to function
- The contracts can be paused and upgrade by the administrators at any time

## Critical Severity

No critical issues were found.

## High Severity

### H01: Replicated Traits Not Updated in Storage

##### Description

The `useTraits()` function does not correctly store a state change tracking replicated traits. On [L160](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarTeleporter.sol#L160) in the AvastarTeleporter contract, the function copies the Prime struct in memory.

```solidity
Prime memory prime = primesByGeneration[uint8(avastar.generation)][avastar.serial];
```

However, the following line [L168](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarTeleporter.sol#L168) only updates the struct in memory and does not register the change in storage.

```solidity
prime.replicated[i] = true;
```

Any changes to `prime.replicated` only occurred in memory and are reversed at the end of the function's execution. The impact of this issue is that the same traits can be used multiple times to mint Replicants. Since the maximum Replicant supply is not directly enforced, this will allow an arbitrarily large number of tokens to be minted.

##### Status

Successfully patched by the Avastars team in [Pull Request #1](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L134). This issue was fixed by replacing the previous struct memory copy with a storage reference.

### H02: Prime Supply Can Exceed the Defined Supply Limit

##### Description

This function `mintPrime()` relies on the mapping `countByGenerationAndSeries` to monitor the active token supply during the minting process. This value is supposed to verify whether the supply of Primes or Promos is bellow maximum allowable number of tokens. Every potential new token validated against a constant, either `MAX_PROMO_PRIMES_PER_GENERATION` or `MAX_PRIMES_PER_SERIES`, to ensure this supply cap is maintained. This happens on [L154-L158](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L154-158) in the PrimeFactory contract.

```solidity
if (_series == Series.PROMO) {
    require(
        countByGenerationAndSeries[uint8(_generation)][uint8(_series)]
        <
        MAX_PROMO_PRIMES_PER_GENERATION
    );
} else {
    require(
        countByGenerationAndSeries[uint8(_generation)][uint8(_series)]
        <
        MAX_PRIMES_PER_SERIES
    );
}
```

If these checks pass, an internal ledger tracking the supply by generation and series is incremented on [L170](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L170).

```solidity
countByGenerationAndSeries[uint8(_generation)][uint8(_series)].add(1);
```

However, this code does not successfully increase the value in storage. The variable remains 0 when the function finishes execution.

The potential implications of this issue are quite serious. The validation always passes regardless of how many Primes or Promos are minted. This allows the token supplies to surpass their hardcoded limits and break the rarity guarantees promised by the application.

##### Recommendation

`countByGenerationAndSeries` returns a value which needs to be stored. Either of the following solutions will correctly patch the issue.

```solidity
// #1
countByGenerationAndSeries[uint8(_generation)][uint8(_series)] =
  uint16(countByGenerationAndSeries[uint8(_generation)][uint8(_series)].add(1));

// #2
countByGenerationAndSeries[uint8(_generation)][uint8(_series)]++;
```

In addition, I recommend increasing the unit test coverage of PrimeFactory to explicitly validate that the maximum supply invariants are not broken. A test checking that the supply count correctly increments is also recommended. `countByGenerationAndSeries` can also be included in the `NewPrime()` event to track more easily.

##### Status

[Successfully patched](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/PrimeFactory.sol#L173) with the 2nd recommendation.

### H03: Unauthorized Access to Prime Array With Replicant Tokens and Vice Versa

_note fix these pop out boxes and integrated different dated notes into single narrative..._

##### Description

`approveTraitAccess()` on [L97-L110](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L97-L110) AvastarTeleporter, `getPrimeByTokenId()` on [L79-L102](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L79-L102) and `getPrimeReplicationByTokenId()` on [L110-L123](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L110-L123) in PrimeFactory, and `getReplicantByTokenId()` on [L64-L85](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/ReplicantFactory.sol#L64-L85) in ReplicantFactory are vulnerable to a subtle bug that enables unauthorized data access. While no immediate consequences have been uncovered, this issue comes very close to unlocking severe effects such as unauthorized or unexpected state modifications.

While both Primes and Replicants maintain separate data structures (an array of structs), they also share a common Avastar struct stored in a global array. Under certain conditions, it is possible for a malicious actor to gain unauthorized access to the array of the other type. This is possible if there are more Primes than Replicants in a given Generation, or vice versa,

Consider a scenario in which there are 5000 Primes and 3000 Replicants in `Generation.ONE`. The total Avastar count is 8000. A malicious user owns a Prime with a `tokenId` of #1500 and a `serial` of #1000. This user calls `getReplicantByTokenId(1500)` with their Prime. The only explicit check in this function easily passes.

```solidity
require(_tokenId avastars.length);
```

The Avastar struct is loaded in memory and its generation and serial are used to access the Replicant struct. Even though this token is a Prime, if its values are in range of any Replicant it can gain unauthorized access to this data structure.

```solidity
Prime memory prime = primesByGeneration[uint8(avastar.generation)][uint256(avastar.serial)];
```

Some functions use a similar pattern to make state changes. Consider a scenario with more Replicants in a Generation than Primes. `approveTraitAccess()` does not verify if the `tokenId` is a Prime or Replicant. Owners can store approvals for access to a Replicant's nonexistent `replicated` array. Out-of-bounds array access can have serious consequences, including the potential access, write, or overwrite arbitrary storage values. See [this example](https://github.com/Arachnid/uscc/tree/master/submissions-2017/doughoyte) for an extreme case of out-of-bounds array access leaning to arbitrary storage changes.

##### Recommendations

- Validate the correct wave of the token entered in all four functions:
  - Add `require(avastar.wave == Wave.PRIME)` after the Avastar struct is loaded in `getPrimeByTokenId()` and `getPrimeReplicationByTokenId()`
  - Initialize the Avastar struct and perform the same check before the loop begins `approveTraitAccess()`
  - Add `require(avastar.wave == Wave.REPLICANT)` to `getReplicantByTokenId()`
- Considering adding an uninitialized value to the Wave enum (similar to Gender) to reduce to risk of erroneous validation of uninitialized tokens validating as `Wave.PRIME` (0 for both cases)
- Add an additional sanity check whenever `avastar.serial` is used to authenticate a state modifying function. For example, add `require (prime.id == avastar.id)` before the loop in `useTraits()`

##### Status

Addressed in [getPrimeByTokenId()](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/PrimeFactory.sol#L92), [getPrimeReplicationByTokenId()](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/PrimeFactory.sol#L119), and [getReplicantByTokenId()](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/ReplicantFactory.sol#L82). Not addressed in `approveTraitAccess()` where it is still possible to approve handlers for Replicant trait access. As this is the only function that modifies storage, I recommend adding a check for `require(avastar.wave == Wave.REPLICANT)`.

### H04: Unchecked Return Call Could Lead to Incorrect Debiting of User Balances

##### Description

[L217](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarPrimeMinter.sol#L217) in the `purchasePrime()` function in AvastarPrimeMinter does not validate the return value of an external call.

User-driven token minting of Primes is initialized in the AvastarPrimeMinter contract. A user deposits enough ether to cover the price of the token they wish to purchase (this price is set and validated off-chain). A worker address with `minter` permissions calls `purchasePrime()` on behalf of the user. The user's balance is debited and the call is forwarded to the AvastarTeleporter contract to mint the token.

```solidity
(tokenId, serial) = teleporterContract.mintPrime(
  _purchaser,
  _traits,
  currentGeneration,
  currentSeries,
  _gender,
  _ranking
);
```

This call should be explicitly validated. If it fails for any reason or returns unexpected data, the `purchasePrime()` function should reverse the changes to the user's and global ether balances.

As presently written, this function returns two expected `uint256` values from the AvastarTeleporter contract: `tokenId` and `serial`. Under certain circumstances, however, it is possible for an external sub-call to fail or return unexpected values without the main transaction reverting. In such a case, the user's ether balance, the ether balance available to the owner to withdraw can be erroneously changed in the contract's storage. Furthermore, `tokenId` and `serial` can be returned as incorrect values.

For example, if the AvastarTeleporter returns data of an incorrect length or type, AvastarPrimeMinter will attempt to decode the calldata into two `uint256` values, regardless of their original type or length.

##### Recommendation

- One option for explicitly validating the call uses the lower-level raw call syntax. This exposes access to two return values: a `bool` indicating whether the call succeeded and a `bytes memory` value with any return data from the function being called. The later can be explicitly checked for the expected length of two `uint256` return values.

The following section of code provides and example implementation of this concept. The logic of the function is:

- perform the same input validation as the original function
- perform the same balance accounting as the original function
- calculate the 4-byte function signature and pack the arguments into the correct `calldata` format using `abi.encodeWithSignature()`
- Explicitly check the success and return data length of the call. It should be 64 bytes long
- Revert if either condition fails
- Parse the raw data with `abi.decode()` into distinct values
- Emit the same event as the original function
- Return `traitId` and `serial` as expected. Because they are named in the function declaration they do not need to be explicitly returned in the function body with something `return (traitId, serial)`
- Note: the function signature of `0xc8c4a80a` will change if the parameter types or name of `mintPrime()` change
- Note: it is possible to craft a colliding signature for an arbitrary function with a different name
- Note: return values do not affect the function signature
- Note: `enum` types are encoded as the smallest `uint` type that can fit all its possible values (`uint8` in this case)
- The resulting `calldata` constructed by this function and sent to AvastarTeleporter is exactly the same as the calldata from: `"teleporterContract.mintPrime(_purchaser, _traits, currentGeneration, currentSeries, _gender, _ranking)"`

```solidity
function purchasePrime(
  address _purchaser,
  uint256 _price,
  uint256 _traits,
  Gender _gender,
  uint8 _ranking
)
  external
  onlyMinter
  whenNotPaused
  returns(uint256 tokenId, uint256 serial)
{
  require(_purchaser != address(0));
  require (depositsByAddress[_purchaser] >= _price);
  require(_gender > Gender.ANY);

  depositsByAddress[_purchaser] = depositsByAddress[_purchaser].sub(_price);
  unspentDeposits = unspentDeposits.sub(_price);

  // structure a low-level call and capture the raw return data
  (bool success, bytes memory data) = address(teleporterContract).call(
	  abi.encodeWithSignature(
      "mintPrime(address,uint256,uint8,uint8,uint8,uint8)",
      _purchaser,
      _traits,
      currentGeneration,
      currentSeries,
      _gender,
      _ranking
	  )
  );

	// was the external call successful?
  require(success);
  // is the return data exactly the length of two `uint256` values?
  require(data.length == 0x40);

  // if so, parse as expected and return the values
  (tokenId, serial) = abi.decode(data, (uint256, uint256));

  emit DepositorBalance(_purchaser, depositsByAddress[_purchaser]);
}
```

Returned calldata:

<br />
<img src={calldata} width="1200" alt="calldata" />
<br />

Another option for increasing the certainty that the returned data is correct is by through relating the two values `require(tokenId >= serial)`.

Finally, consider if AvastarPrimeMinter needs the return values at all. They are only used in an event that largely duplicates a similar event emitted in AvastarTeleporter.

##### Status

This issue was acknowledged and determined to be low risk based on the trust model between the two contracts. New unit tests were added to check for failing conditions.

One remaining risk is this (highly contrived) hypothetical in which `purchasePrime()` receives a longer than expected return value and incorrectly parses the result, leading to incorrect data being logged for `tokenId` and `serial`. The likelihood of this case occurring increases if the AvastarTeleporter contract is untrusted or if it modifies the behaviour of the `mintPrimes()` function.

Consider a modified `mintPrime()` function that returns 128 bytes of garbage data. `purchasePrime()` accepts this data without generating an error or halting execution, despite the return being longer than the expected 64 bytes. It still parses the first and second 32-byte words as `uint256`, regardless of their original data type.

```solidity
// EXAMPLE
// this function has the same 4-byte signature (0x46c91e59) as the real `mintPrime()` but returns garbage data for illustrative purposes

function mintPrime(address, uint256, uint8, uint8, uint8, uint8)
	external
	pure
	returns(bytes memory)
{
	// assembly used to return 128 bytes of data without prepending length and location values
	assembly {
		// begin at free memory pointer
		let start := mload(0x40)
		// start position of fourth memory slot
		let offset := 0x80
		// 0xffff...ffff
		let junk := sub(0, 1)

		// loop start condition
		for { let i := 0 }
		// loop end condition
		lt(i, offset)
		// increment memory position by one slot for each iteration
		{ i := add(i, 0x20) } {
			// main loop logic
			// store junk at current memory slot
			mstore(add(start, i), junk)
		}
		// return 128 bytes of junk from memory
		return (start, offset)
	}
}
```

<img src={return_data} width="1200" alt="return_data" />

There have also been changes to the input validations in these functions which alters the set of possible outcomes. `mintPrime()` and `mintReplicant()` can now successfully mint a token with a Gender of `ANY`, which was previously disallowed. A minter level account can do this by accident or maliciously. If such a token is minted, its metadata will display as Female based on the ternary operation on [L261](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L261) and [L289](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L261) of AvastarMetadata.

```solidity
metadata = strConcat(metadata, (gender == Gender.MALE) ? ' Male ' : ' Female ');
```

`mintReplicant()` also removes a check that the owner is not `address(0)`. However, this is validated again in the ERC-721 `_mint()`. This redundancy allows the function to revert as expected if `address(0)` is passed as the token owner.

## Medium Severity

### M01: Denial of Service and Griefing During Minting

##### Description

The Avastars payment system opens up a potential griefing vector during the minting process. It's possible for a malicious user to continuously deposit funds as if they wanted to purchase an Avastar, wait for the minter to send a callback transaction, then front-run this transaction and withdraw their funds. This sequence involves the `deposit()` function on [L150-156](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarPrimeMinter.sol#L150-L156) and the `withdrawDepositorBalance()` function on [L175-184](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarPrimeMinter.sol#L175-L184) in AvastarPrimeMinter.

In this scenario the `purchasePrime()` callback transaction on [L200-L222](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarPrimeMinter.sol#L200-L222) send from the minter will fail because the depositor no longer has a sufficient balance to proceed with the purchase. Given a limited number of minter addresses, this and could slow or prevent service for other users attempting to buy tokens. While the malicious actor does not gain anything directly from this type of attack, it does have the potential to slow or halt operation.

Another variation of this DoS vector involves griefing the minter system with small dust deposits from different addresses. While any backend system could adapt quickly by filtering out these deposits, a motivated attacker could flood a stream of 1 wei deposits from new accounts. Reliance on external validation of deposit data is a potential weak point in the decentralization of the application.

##### Recommendation 1

Maintain the current architecture while making the minters resilient to changing conditions.

The `minters` should:

- Detect and validate incoming user transactions
- Match these deposits with price and trait information from the backend
- Track gas prices, confirmation times, and network conditions
- Replace the nonces of any stuck transactions
- React to user withdraws and adjust transactions accordingly
- Maintain a clear priority queue for deposits in the event of multiple users attempting to claim the same hash
- Balance ether available for gas between the minters
- Maintain reliable access to the Ethereum network with redundancy in the node infrastructure

Risks:

- Key loss / account compromise
- Downtime and maintenance requirements for backend nodes and associated scripts
- Trust model requires users have faith in a closed system

##### Recommendation 2

An alternative model involves users committing some information on-chain along with their deposit. This could be a signature or hashed value of the token traits with an additional salt. To prevent withdrawal griefing, users could be require to commit to some minimum deposit period. If the transaction is not completed by the minter callback in a reasonable time frame, their ability to withdraw is unlocked.

##### Status

This issue is partially mitigated by the Avastars team's plan to run multiple `minters`. In practice, the number of minters could be scaled to match demand. However, the associated key management risks would also increase.

### M02: Admin Overwrite Permissions

##### Description

Administrator accounts with special permissions have the ability to write or overwrite arbitrary data. There are little or no restrictions on unintended state modification in the following locations:

- `extendTraitArt()` on [L232-L239](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/TraitFactory.sol#L218-L225) and `setAttribution()` on [L162-L171](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/TraitFactory.sol#L162-L171) in TraitFactory
- `setTokenUriBase()` on [L102-L110](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarMetadata.sol#L102-L110), `setMediaUriBase()` on [L118-L126](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarMetadata.sol#L118-L126) and `setViewUriBase()` on [L134-L142](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarMetadata.sol#L134-L142) in AvastarMetadata
- `setMetadataContract()` on [L51-L65](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarTeleporter.sol#L51-L65) in AvastarTeleporter
- `setTeleporterContract()` on [L79-L92](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarPrimeMinter.sol#L79-L92) in AvastarPrimeMinter

If an administrator key is compromised, used maliciously, or if a malformed transaction is accidentally sent contract state be omitted, altered, or removed. Specific examples include:

- In `setTeleporterContract()`, the AvastarTeleporter contract address can be changed at any time by any address with `sysAdmin` privileges. Users may have deposited funds to purchase a token but do not have a guarantee the correct AvastarTeleporter contract is called. The `whenPaused()` modifier does not meaningfully prevent this case as it can be toggled at any time by a `sysAdmin`, even within the same transaction as `setTeleporterContract()`
- Similarly, `setMetadataContractAddress()` can be modified at any time, potentially breaking the link between the ERC-721 token and its associated artwork and metadata. On-chain svg images associated with the an NFT is a core component of the Avastars project. As presently constructed, users do not have certainty in the immutability of token metadata
- Generation and Series can be both changed at any time and do not need to follow any sequential order. A malicious or compromised `sysAdmin` could use these feature to mint specific token numbers with perceived market significance, unexpectedly end a given Series or Generation, and generally cause mayhem
- Traits cannot be updated after a generation begins, but they can be prevented from being added. One accidental or malicious minting per generation can render the entire contract unusable if the traits have not been completely added
- `setTokenUriBase()`, `setMediaUriBase()`,`setViewUriBase()` can be altered at will or improperly initialized with empty strings

While many of these cases do not pose an explicit security risk as long as the administrator remain trustworthy, it does undermine the minimized trust model that many NFT users expect. Furthermore, unchecked admin powers present an ongoing threat if their keys are ever compromised. Another risk of this design pattern is the ["bus factor"](https://en.wikipedia.org/wiki/Bus_factor). Correct initialization and ongoing operation of the contracts is reliant a small and centralized group of privileged addresses.

##### Status

The Avastars Team has removed the direct ability to overwrite storage. They have also added an `onlyBeforeProd()` modifier on [L41-L44](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/TraitFactory.sol#L41-L44) in TraitFactory that provides users with greater assurances that token data will not change after minting. There remains the risk of a generation accidentally or maliciously beginning before traits are added. This would prevent the planned traits and other metadata from being completed and may lead to a situation where contracts needed to be redeploy or wrapped to correctly link token metadata.

### M03 Irreversible Permissions and Other Access Control Issues

##### Description

The current implementation of the [AccessControl](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AccessControl.sol) contract does not include a method for removing privileged accounts. This poses several potential risks, including:

1. The AvastarPrimeMinter (and presumably AvastarReplicantMinter) contracts must have minter permissions in the AvastarTeleporter contract to successfully forward user purchases. A smart contract with elevated permissions and access to the interface methods of the AvastarTeleporter contract presents a wider attack surface. Hypothetically, if an attacker re-entered the AvastarPrimeMinter contract, they could make a permissioned call to another contract where `msg.sender` has `minter` permissions

2. AvastarPrimeMinter contracts can be `paused` or `upgraded` but their minter status cannot be revoked. This makes any access-related security issues more difficult to contain

3. Potential network congestion during the minting process will likely necessitate multiple addresses with minter permissions to keep the contracts functioning smoothly. Risk increases with every additional address granted special permissions

##### Recommendations

- Add a `removeMinter()` function allows a higher-tiered administrator to spin up and tear down `minters` as needed. This can reduce risk in the event that a minter key is lost or compromised key
- The AvastarPrimeMinter contract should ensure that an address is assigned the `owner` role during construction. The comment on [L21](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AccessControl.sol#L21) in AccessControl create the impression that the deploying address gains both `owner` and `sysAdmin` permissions. However, `owner` status is not assigned automatically

```solidity
    /**
     * @notice Sets `msg.sender` as owner and system admin by default.
     * Starts paused. System admin must unpause after full migration.
     */
    constructor() public {
        admins.add(msg.sender);
}
```

##### Status

Mostly addressed. Addresses with `owner` privileges can now remove roles from other addresses by calling the `stripRoles()` function on [L149-L165](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AccessControl.sol#L149-L165) in AccessControl. This provides greater flexibility for managing addresses with the `minter` roles. In an attack scenario, however, any address with the `sysAdmin` role effectively has access the privileges of all roles. A `sysAdmin` can grant themselves `owner` and/or `minter` privileges.

The following risks remain if the Avastars trust model breaks down:

- Nothing in the contracts enforces that any `owner` is ever added
- Nothing in the contracts enforces that an `owner` will also receive `sysAdmin` privileges, though this was described as an intended feature
- If a `sysAdmin` or `owner` address is compromised they can strip any other honest addresses with of their roles and gain complete control of the contracts
- If the only remaining `owner` strips all addresses with `sysAdmin` permissions of their roles, there will be no way to pause or update the contract
- It is possible to remove all of the `sysAdmin` and permanently lock the ability to add new roles

### M04: Unchecked Array Length Creates uint8 Overflow in for Loop

##### Description

`approveTraitAccess()` on [L97-L110](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L97-L110) in AvastarTeleporter accepts a dynamically sized array:

```solidity
function approveTraitAccess(address _handler, uint256[] calldata _primeIds) external {
```

The array length is not validated and is used to define the upper limit of iterations in the for loop on [L101](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L101).

```solidity
for (uint8 i = 0; i < _primeIds.length; i++) {
```

The starting variable `i` is a `uint8` type and will overflow to 0 when its value increments beyond 255. The caller can force this overflow by calling the function with more than 255 items in the `_primeIds` array.

The function checks if the caller owns the tokenIds provided in the `_primeIds` array. However, it does not check for duplicate values. A malicious caller only needs to own 1 token and can pass the same id for any number of item in the array payload.

##### Recommendations

- Do not allow dynamic arrays as input in an external or public function. When an array must be used, define a sensible fixed length. For example: `uint256[8] calldata _primeIds`
- Favour explicit validation of inputs rather than relying on integer type lengths to enforce the range of acceptable values. Since it is unclear that the maximum number the type can hold is acting as a validation, it may fail silently or be unintentionally removed in future versions of the code base
- Do not allow a user-control parameter to dictate the upper bound of a loop
- The event `TraitAccessApproved(_handler, _primeIds)` should also validate sensible limits before accepting an array

##### Status

[Fixed](https://github.com/Dapp-Wizards/Avastars-Contracts/commit/39f3c39b13e6c8aae04f87095d665be0e17747e1#diff-9415ec44e4b764c4ffda3611419a3e92). The function now explicitly checks the length of the array and prevents the overflow. The function still accepts an unbounded array but explicitly limits the maximum size to 256.

### M05 Dynamic Array Used for Fixed Length Property

##### Description

The `bool[] replicated` array on [L77](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTypes.sol#L77) in the Prime struct is defined as a dynamic array. Its purpose is to track the state of each Prime's traits and flag them when they are used to produce a Replicant. The intended design is for each trait to be single-use.

```solidity
struct Trait {
  uint256 id;
  Generation generation;
  Series[] series;
  Gender gender;
  Gene gene;
  Rarity rarity;
  uint8 variation;
  string name;
  string svg;
}
```

The array is initialized with 32 null values during the token minting on [L166](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L166) in PrimeFactory.

```solidity
primesByGeneration[uint8(_generation)].push(
	Prime(
    tokenId,
    serial,
    _traits,
    new bool[](32),
    _generation,
    _series,
    _gender,
    ranking
  )
);
```

Since this is still a dynamic array its length can potentially mutate to greater or less than 32. Since the number of traits is always fixed, this data type seems adds unnecessary risk.

##### Recommendation

- Initialize the struct with a fixed-length array `bool[32] calldata _traitFlags` to explicitly limit its size
- Consider offering a function that allows for the use of a single trait accessed by index so that the entire array does not need to be looped through with every use
- Consider using a non-array data type like `bytes32` to track replicated traits. Flip a bit when the flag is set

##### Status

Mostly addressed. The array is now [defined in the struct](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarTypes.sol#L77) as fixed length array.

```solidity
bool[12] replicated;
```

This [change also includes a minor adjustment](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/PrimeFactory.sol#L166-L170) to how the array is initialized during token minting.

```solidity
// Create and store Prime struct
bool[12] memory replicated;
primesByGeneration[uint8(_generation)].push(
    Prime(tokenId, serial, _traits, replicated, _generation, _series, _gender, _ranking)
);
```

Changing to a non-array data type or expanding the functionality to take advantage of index-specific access remains outside of the scope for this iteration of the contract.

### M06: Unchecked Minter Privileges Require Extensive User Trust During Purchases

##### Description

A core design choice in the project involves extensive permissions for privileged accounts. This allows the project team to reduce their exposure to some risks in a live network setting and maintain a higher degree of control over the operation of the smart contracts. The generation of traits, randomization of genes, and many other features are centralized and managed off-chain.

Avastars is unable to offer users any assurances when they deposit their funds in the smart contact to buy a token. Nothing technical enforces this good-faith promise of honesty.

The `minter` role can mint new tokens for no cost and gift them to any address. This role can also mint arbitrary tokens and charge users any amount up to the maximum they deposited. Nothing at the contract level ensures that the users receive the token they intended to buy. This effectively means that any user funds deposited into the contract can be stolen by compromised accounts or malicious administrators. Furthermore, the `minter` role can selectively refuse service to users or process orders out of sequence. Users have no recourse in any of these cases. Their trust is required.

##### Recommendation

While I strongly discourage this type of permissioned architecture, it was already deeply embedded in the code base when the audit process began. In lieu of changing the system, I recommend very clear and open communication with users about the elements of the project that are centralized.

##### Status

The Avastars team understands that the application has been designed with a model that requires a high degree of user trust. Risk from compromised minter accounts is mitigated to some degree with the addition of the `stripRoles()` function.

### M07: Contract Does Not Enforce Supply Limit for Replicants

##### Description

The contracts do not enforce a cap on the Replicant supply. As presently designed, a `minter` can create an unlimited supply of Replicants without the need to use traits from Primes or respect the maximum Prime supply.

##### Status

Addressed, though with unnecessary code duplication. The issue was patched by adding the following limit on [L15](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/ReplicantFactory.sol#L15) of Replicant Factory.

```solidity
uint16 public constant MAX_REPLICANTS_PER_GENERATION = 25200;
```

A new mapping called `replicantCountByGeneration` was added on [L80](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarState.sol#L80) of AvastarState. This variable is validated and then incremented in `mintReplicant()` on [L106-L138](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/ReplicantFactory.sol#L106-L138) of ReplicantFactory. However, the count of Replicants in a generation is already tracked in `replicantsByGeneration` on [L43](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarState.sol#L43) of AvastarState. The length of this array duplicates the same information as the newly added incremented count.

### M08 Open Access to Uninitialized Storage Pointers

##### Description

If `getAttributionByGeneration()` on [L133-L144](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/TraitFactory.sol#L133-L144) in TraitFactory is called with a valid but unset Generation as an argument, it allows access to an uninitialized storage pointer.

```solidity
Attribution memory attrib = attributionByGeneration[uint8(_generation)];
```

This mapping attempts to reference an Attribution struct that does not yet exist. Access to uninitialized storage can have dangerous and unpredictable effects, including jumps to arbitrary pieces of code.

##### Recommendations

- Create a separate flag not stored in the struct that is toggled on when the `setAttribution()` function is called
- Add an explicit check for data saved at a given Attribution mapping before allowing access to that storage location

##### Status

Mitigated with a [check that prevents](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/TraitFactory.sol#L139) the function from continuing execution if `attributionByGeneration` is not set. The act of checking whether or not it set still accesses an uninitialized storage pointer. However, the risk of unauthorized access or corruption of other storage values is minimal since it is a mapping rather than a simple state variable.

Mappings use a hash function to generate the starting position of their storage slot(s). These locations are deterministic but distributed over a 2\*\*256-1 search space. This keeps them far away from the 0-indexed storage keys used by simple static types. The chance of discovering a collision is essentially 0. If `attributionByGeneration` needs to store string values longer than 32 bytes, the next storage location is generated from a (deterministic) hash. See the [Solidity Docs](https://solidity.readthedocs.io/en/latest/miscellaneous.html#mappings-and-dynamic-arrays) for more information.

## Low Severity

### L01: Out of Bounds Enum Inputs Can Trigger Invalid Opcode

##### Description

When used as an argument in the following function, an out-of-range `enum` value triggers an `INVALID` opcode.

- `getTraitIdByGenerationGeneAndVariation()` on [L43-L54](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/TraitFactory.sol#L43-L54), `getAttributionByGeneration()` on [L125-136](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/TraitFactory.sol#L125-L136), `setAttribution()` on [L162-L171](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/TraitFactory.sol#L162-L171) and `createTrait()` on [L185-L223](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/TraitFactory.sol#L185-L223) in TraitFactory
- `getPrimeByGenerationAndSerial()` on [L43-L65](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/PrimeFactory.sol#L43-L65) and `mintPrime()` on [L138-L177](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/PrimeFactory.sol#L138-L177) in PrimeFactory
- `getReplicantByGenerationAndSerial()` on [L32-L52](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/ReplicantFactory.sol#L32-L52) and `mintReplicant()` on [L99-L129](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/ReplicantFactory.sol#L99-L129) in ReplicantFactory
- `setCurrentGeneration()` on [L101-L105](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarPrimeMinter.sol#L101-L105), `setCurrentSeries()` on [L113-L116](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarPrimeMinter.sol#L113-L116) and `purchasePrime()` on [L200-L220](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarPrimeMinter.sol#L200-L220) in AvastarPrimeMinter
- `assembleTraitMetadata()` on [L315-L376](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarMetadata.sol#L315-L376) in AvastarMetadata

This is an assert-style exception that burns all of the gas in the transactions. In general, this type of exception should never happen in production code. The `REVERT` opcode provides the same assurances with the option of including an additional error message if used with `require()`. The `REVERT` opcode does not burn all remaining gas sent with transaction.

##### Recommendation

I recommend adding explicit validation for any input with an enum type in non-admin functions. While this needs to be balanced against the effort of refactoring the full code base, heavy use of the enum type is likely creating more complexity than it is clarity.

##### Status

The Avastars Team has decided that the impact of this issue does not necessitate the substantial refactoring required.

### L02: State Access in Event Emitted After External Call

##### Description

In `withdrawDepositorBalance()` on [L175-L184](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarPrimeMinter.sol#L175-L184) in AvastarPrimeMinter, state access occurs after an external `transfer` call an arbitrary address. Accessing state after an untrusted external call brings potential risk for reentrancy, particularly now that `transfer` is able to trigger code execution with the updated storage opcode costs. If the call fails incorrect data might be logged in the event.

##### Recommendation

Emit the local variable `depositorBalance` rather than accessing state with `depositsByAddress[msg.sender]`.

##### Status

[Addressed](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarPrimeMinter.sol#L196). The event no longer accesses mutable state after the external `transfer` call. There remains a very small risk of reentrancy with the post-Istanbul opcode gas pricing. See [OpenZeppelin's recommendations](https://blog.openzeppelin.com/reentrancy-after-istanbul/) on avoiding `transfer` for more information.

### L03: Trait Hashes Rely on External Validation

##### Description

Creating and validating the trait hash for each Avastar happens entirely off-chain. There are a significant number of possible hashes which do not map to valid traits. The functions `assembleTraitMetadata()` and `renderAvastar()` have no mechanism for parsing invalid genes other than omitting them. The application relies on an external validation systems and is not enforced at the smart contract level.

##### Status

Acknowledged. Centralized external validation is part of the application's trust model.

### L04: Duplicate Values Possible in Series Array

##### Description

The function `createTrait()` on [L175-L208](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/TraitFactory.sol#L175-L208) will accept duplicate values for the Series\[] array. For example:

```solidity
createTrait(..., [Series.ONE, Series.ONE, Series.ONE], ...);
```

Correct trait initialization relies on external validation.

##### Status

Acknowledged. External validation of the arguments passed to `createTrait()` is part of the application's trust model.

### L05: traitHandlerByPrimeTokenId Gives a Handler Access to All of a User's Unused Traits

##### Description

The current design of the function `approveTraitAccess()` on [L97-L110](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L97-L110) in AvastarTeleporter does not allow a token owner to atomically control approvals individual traits. The `bool` flag system could be extended to allow for granular trait control based on array index. There is limited benefit to tracking traits individually if they cannot be used as atomically.

##### Status

Acknowledged. This is the intended functionality. Granular control of trait approval is beyond the scope of this feature.

### L06: upgradeContract() Does Not Check for Null Address

##### Description

The function `upgradeContract()` on [L123-L127](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AccessControl.sol#L123-L127) in AccessControl does not check the validity of the address input. It's possible for a `sysAdmin` to accidentally or maliciously set the address of new contract in to `address(0)` when calling the `upgradeContract()`.

##### Recommendation

This should be explicitly disallowed.

##### Status

[Addressed](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AccessControl.sol#L107). By adding the following line:

```solidity
require(_newAddress != address(0));
```

### L07: isAvastarTeleporter() and isAvastarMetadata() Checks Are Insufficient

##### Description

The functions `isAvastarTeleporter()` on [L43](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L43) and `isAvastarMetadata()` on [L94](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarMetadata.sol#L94) provide limited assurances that the new contracts are actually AvastarTeleporter or AvastarMetadata. Returning a value as always `true` does not verify that the prospective contract implements the intended functionality or interface. Any contract could add a function by the same name which contained arbitrary logic and still returned true (mitigated somewhat by admin privileges).

##### Recommendation

These contracts could register their interfaces in the ERC-165 registry and perform a much more robust interface checks.

##### Status

Acknowledged. The risk of a contract maliciously spoofing the return value is reduced by the application's trust model. More robust interface checks are beyond the scope of this version of the contracts.

### L08: Tightly Packing Traits Struct Will Save Gas

##### Description

Reordering the declaration of variables in the Trait struct on [L60-L71](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTypes.sol#L60-L71) in AvastarTypes will reduce the size of every instance of this struct by one full storage slot (32 bytes). This will save gas and reduce the contract size during deployment. It will also reduce the gas costs when new Traits are added.

The struct is currently declared as:

```solidity
struct Trait {
	uint256 id;                      // slot 1: 32/32 bytes used
	Generation generation;           // slot 2: 01/32 bytes used
	Series[] series;                 // slot 3: 32/32 bytes used
	Gender gender;                   // slot 4: 01/32 bytes used
	Gene gene;                       // slot 4: 02/32 bytes used
	Rarity rarity;                   // slot 4: 03/32 bytes used
	uint8 variation;                 // slot 4: 04/32 bytes used
	string name;                     // slot 5: 32/32 bytes used
	string svg;                      // slot 6: 32/32 bytes used
}
```

##### Recommendation

Reorganizing the lexical order of declaration and tightly packing the variables into one fewer storage slot can optimize this structure. This change will reduce the gas cost for each new trait created by 20k using one fewer `SSTORE` opcode.

```solidity
struct Trait {
	uint256 id;                      // slot 1: 32/32 bytes used
	Generation generation;           // slot 2: 01/32 bytes used
	Gender gender;                   // slot 2: 02/32 bytes used
	Gene gene;                       // slot 2: 03/32 bytes used
	Rarity rarity;                   // slot 2: 04/32 bytes used
	uint8 variation;                 // slot 2: 05/32 bytes used
	Series[] series;                 // slot 3: 32/32 bytes used
	string name;                     // slot 4: 32/32 bytes used
	string svg;                      // slot 5: 32/32 bytes used
}
```

<img src={storage_layout} width="1200" alt="storage_layout" />

##### Status

[Accepted](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarTypes.sol#L60-L71). The effective gas cost of `createTrait()` was reduced by approximately 20%.

### L09: setAttribution() Strings Can Be Set to Null

##### Description

In the function `setAttribution()` on [152-161](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/TraitFactory.sol#L152-L161) in TraitFactory it's possible for a `sysAdmin` to accidentally or maliciously set the attribution of a Generation as an empty string.

##### Recommendation

Check that the length of `_artist` and `_infoURI` is > 0.

##### Status

[Addressed](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/TraitFactory.sol#L159). This function now checks that the length of the input is greater than 0.

### L10: TraitAccessApproved() Event Does Not Necessarily Reflect State Changes

##### Description

The `approveTraitAccess()` function on [L97-L110](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L97-L110) in AvastarTeleporter emits the event `TraitAccessApproved()` regardless if any new traits have been approved or if any handlers have changed. It is possible to provide an empty array of `_primeIds` as an argument for this function. It is also possible to provide a set of `_primeIds` that have already been approved to the given handler. In both cases, the event unnecessarily broadcasts when there are no state modifications.

##### Status

[Addressed](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarTeleporter.sol#L101-L120). The function now checks that array length for `_primeIds` is greater than 0. It will also only complete execution if there is a state change.

### L11: Functions With Unnecessarily Permissive Visibility

##### Description

The following functions are not used internally and can safely be changed from `public` to `external`.

- `getPrimeByTokenId()` on [L79-L102](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L79-L102), `getPrimeReplicationByTokenId()` on [L110-L123](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L110-L123) in PrimeFactory
- `getReplicantByTokenId()` on [L64-L85](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/ReplicantFactory.sol#L64-L85) in ReplicantFactory
- `getPrimeByTokenId()` on [L49-L59](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/IAvastarTeleporter.sol#L49-L59) and `getReplicantByTokenId()` on [L71-L80](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/IAvastarTeleporter.sol#L71-L80) in IAvastarTeleporter
- `pause()` on [L159-162](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AccessControl.sol#L159-L162) and `unpause()` on [L167-170](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AccessControl.sol#L167-L170) in AccessControl
- `tokenURI()` on [L83-L89](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L83-L89) in AvastarTeleporter

##### Status

Addressed. Visibility changed to `external` on all 8 recommended functions.

### L12: Limited Unit Test Coverage of Token Dependencies and Certain Branches of the Core Contracts

##### Description

See [Test Coverage][#a02-test-coverage] section in the Appendix for more detail.

A significant percentage of the branches in AvastarPrimeMinter, AvastarTeleporter, PrimeFactory, ReplicantFactory, TraitFactory have limited or no unit test coverage. Large parts of the inherited token functionality are not covered by unit tests. Testing the interactions of the OpenZeppelin and Avastars contracts may uncover bugs not present in common implementations of the standard ERC-721 contracts.

##### Status

Improved. Unit test coverage improved in areas identified in the audit and in general. Improving coverage for other under-tested functionality like token approval and transfer is a goal.

### L13: Default Truffle Project Settings Targets Outdated Evm Version

##### Description

By default, the 0.5.12 solc compiler targets the `petersburg` evmVersion. Using the new opcodes and updated gas pricing available in the `istanbul` evmVersion will better replicate current conditions of the main net. The default evmVersion was changed to `istanbul` in solc 0.5.14. (Note: while `berlin` is the most recent evmVersion available it is still considered experimental).

##### Status

Addressed. The core contracts now use solc 0.5.14, which set `istanbul` as the default evmVersion. This change was confirmed in the contract build artifacts.

### L14: Unnecessary Duplication of Avastar Storage

##### Description

`Avatar.traits` on [L96](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTypes.sol#L96) in never exposed as a public variable and is only used once to check if a hash is not repeated in a generation. `isHashUsedByGeneration` is already validated during `mintPrime()` and `mintReplicant()`. Storing and validating the same hash twice is redundant.

##### Status

Acknowledged. This is an optimization and does not pose a direct security risk.

### L15: Inconsistent Use of uint Alias

##### Description

In various parts of the code base variables are declared with the `uint` alias. They should be replaced with `uint256` in favour of explicitness and to avoid unintentional implicit type conversion.

##### Status

Acknowledged. This is primarily a style note. The main risk of this item comes from potential human error during development. For example, overlooking an implicit type conversion or type casting when a variable is changed or moved.

### L16: AvastarReplicantMinter Contract Not Available

##### Description

At the time of the audit the AvastarReplicantMinter contract was not available for review. The interactions of Replicants with the other components of the system may introduce new attack surfaces or create scenarios where benign bugs become security risks.

##### Status

Acknowledged. This contract was not within the scope or timeline of the audit.

## Note

### N01: Floating Pragmas

##### Description

All base Avastar contracts should specify a fixed pragma version to associate with the development, testing, and auditing of these contracts. They currently use a floating pragma.

```solidity
//fixed
pragma solidity 0.5.12;

//floating
pragma solidity ^0.5.12;
```

##### Status

Addressed in all core contracts, which are now locked to solc version 0.5.14. The OpenZeppelin dependencies still use floating pragmas with either ^0.5.0 or ^0.5.5.

### N02: Unused Library Method With External Call

##### Description

While unlikely to be accessed, I would not include the code for the `sendValue()` function on [L61-L67](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/utils/Address.sol#L61-L67) in the OpenZeppelin Address library. A bug allowing unexpected `JUMPs` could lead to the execution of the low-level `call.value()` in this function.

##### Status

Acknowledged. In general, I do not recommend modifying OpenZeppelin dependencies. However, this particular function is a very recent addition to the library and is not as battle-tested as the majority of their code base. There is a very small risk that unexpected behaviour in another part of the contract could jump to and/or trigger the execution of this function. This is purely hypothetical, however, and very unlikely. The potential risk is further reduced by the fact that AvastarTeleporter is not designed to hold ether.

### N03: Potentially Unsafe Use of abi.encodePacked() if Hashed in the Future

##### Description

The function `strConcat()` on [L42-L46](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarBase.sol#L42-L46) in AvastarBase uses `abi.encodePacked()` with two with dynamic length types. The current implementation is benign. However, if the same function is reused in the future with for some other purpose that includes a hash, its output can produce collisions.

##### Status

-- Acknowledged. This is an informational note about a recently discovered bug related to combining dynamic data types with `abi.encodePacked()`. See [SWC-133](https://swcregistry.io/docs/SWC-133) for more information. The current Avastars code is not at risk. However, it uses a pattern close enough to the vulnerable example that a warning is warranted. There is only a risk if the `strConcat()` function is adapted or extended in future updates and used to generate hashes or perform validations.

### N04: assembleArtwork() Relies on Exponentiation of Mixed Uint Types

##### Description

The function `assembleArtwork()` in TraitFactory relies on exponentiation of mixed uint types on [L249](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/TraitFactory.sol#L249). Solidity used to have a bug that produced unexpected values when small types were used in exponentiation. The resulting type of an exponentiation of two different sized types is the type of the base. It used to be the smallest type that can hold both the type of the base and the type of the exponent.

##### Status

Acknowledged. This was an informational note about Solidity's recent history with serious bugs and changing behaviour in mixed type exponentiation.

### N05: AvastarPrimeMinter Should Set AvastarTeleporter Contract in Constructor

##### Description

- This would be consistent with how the AvastarTeleporter address is set in the Metadata contract.

##### Status

[Addressed](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarPrimeMinter.sol#L77-L87).

### N06: Set Short Circuits With Mostly Likely Case First

##### Description

When two conditions are evaluated, position the one that will most frequently fail first to reduce overall gas costs.

```solidity
if (_series == Series.PROMO) {
	require(countByGenerationAndSeries[uint8(_generation)][uint8(_series)]
  <
  MAX_PROMO_PRIMES_PER_GENERATION);
} else
	require(countByGenerationAndSeries[uint8(_generation)][uint8(_series)]
  <
  MAX_PRIMES_PER_SERIES);
}
```

In this example from `mintPrimes()` the if / else statements could flip.

##### Status

[Addressed](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/PrimeFactory.sol#L156-L160). The conditions in the above example were reversed.

```solidity
if (_series != Series.PROMO) {
  require(count < MAX_PRIMES_PER_SERIES);
} else {
  require(count < MAX_PROMO_PRIMES_PER_GENERATION);
}
```

### N07: State Variable Initialized With Default Value

##### Description

On [L64](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AccessControl.sol#L64) of AccessControl a state variable is unnecessarily initialized with its default value (false || 0).

```solidity
bool public upgraded = false;
```

##### Status

Acknowledged. In this example, the redundant declaration of the default value improves the clarity and readability of the code.

### N08: Test Coverage Treats Invalid Execution States as Passing Conditions

##### Description

This is connected to the `enum` validation issue in [L01](#l01-out-of-bounds-enum-inputs-can-trigger-invalid-opcode). As a best practice, `INVALID` execution states should not be the intended outcome of a test.

##### Status

Acknowledged as part of L01.

### N09: Event Parameters Are Not Indexed

##### Description

No events in the code base take advance of the `indexed` keyword that allows for easier data retrieval from events.

##### Status

This was an auditor error. There are, in fact, four events which use the `indexed` keyword. This issue is retracted.

### N10: Empty Events Are Emitted

##### Description

The events `ContractPaused()` and `ContractUnpaused()` in AccessControl are empty. They could contain the address of the caller or other relevant data.

##### Status

Acknowledged. Empty events still offer the ability to subscribe to and filter on-chain activity.

### N11: Unnecessary Casting to Own Type

##### Description

There are several instances of unnecessary type casting:

- `checkFranchiseBalance()` on [L124-L126](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarPrimeMinter.sol#L124-L126) and `withdrawFranchiseBalance()` on [L135-L141](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarPrimeMinter.sol#L135-L141) of AvastarPrimeMinter do not need cast `uint256(address(this).balance)` as it is already of the `uint256` type
- The following functions all accept a `uint256` value for `serial` and then explicitly recast it as `uint256`:
  - `renderAvastar()` on [L86-L96](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarFactory.sol#L86-L96) of AvastarFactory, -`getPrimeByTokenId()` on [L79-L102](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L79-L102), `getPrimeByGenerationAndSerial()` on [L43-L65](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L43-L65), and `getPrimeReplicationByTokenId()` on [L110-L123](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/PrimeFactory.sol#L110-L123) in PrimeFactory
  - `getReplicantByTokenId()` on [L64-L85](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/ReplicantFactory.sol#L64-L85) of ReplicantFactory
  - `mintAvastar()` on [L26-L66](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarFactory.sol#L26-L66) in AvastarFactory

##### Status

Partially addressed. The `serial` variables in the 2nd list item were updated. The `uint256(address(this).balance` examples are unchanged.

### N12: Unattributed Use of an External Dependency

##### Description

The `uintToStr()` function in AvastarBase is included without attribution. The version used appears to originally come from Oracalize. An updated version is part of the OpenZeppelin contracts as Strings.sol. Both contracts require reproduction with a license.

##### Status

[Addressed](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarBase.sol#L12-L13).

### N13: Variable Shadowing

##### Description

The state variables Traits, `name`, `symbol`, and `_name` are shadowed in multiple places in the contract structure.

##### Status

Acknowledged. While this is primarily an informational note, variable shadowing can produce issues beyond readability or developer error. The primary risk of naming conflicts is unexpected and/or undocumented behaviour in the compiler, particular in contracts with multiple levels of inheritance and nested constructor arguments. See [SWC-119](https://swcregistry.io/docs/SWC-119) and this [Solidity GitHub issue](https://github.com/ethereum/solidity/issues/2563) for more info.

### N14: External Calls in Loops

##### Description

The function `assembleTraitMetadata()` on [L319-L380] in AvastarMetadata makes an external call in each iteration of a for loop.

##### Status

Acknowledged. This item is primarily informational and does not pose a significant security risk. In this case, however, the number of calls adds significant gas overhead. The following recommendations are meant to clarify the original note but the substantial refactoring required is realistic to incorporate before the contract goes lives.

Selectively batching calls from AvastarMetadata to AvastarTeleporter can substantially reduce the total number of calls required. For example, the AvastarMetadata contract is expected to make 30 independent calls to AvastarTeleporter during the normal execution of a single invocation of `getAvastarMetadata()`. While some repetition is necessary with this design pattern, there are at least three opportunities for optimization.

1.  `getAvastarMetadata()` checks that `_uint256 is a valid token` 4 times, each making a separate call to AvastarTeleporter.

- [L220](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L220): `require(_tokenId < teleporterContract.totalSupply(), INVALID_TOKEN_ID)` checks this condition explicitly
- [L233](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L233) `wave = teleporterContract.getAvastarWaveByTokenId(_tokenId)` checks that the `tokenId` is less than the length of the Avastars array, which is equivalent to `totalSupply()`
- [L247](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L247): `viewURI(_tokenId)` checks `totalSupply()` again
- [L279](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L279): `mediaURI(_tokenId)` checks `totalSupply()` again

2.  An [initial call](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L233) is made to get `Avastar.wave`. Based on the result, a [separate call](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L236-L240) then retrieves either a Prime or Replicant struct. If the Avastar struct stored Series, Gender and `ranking`, all of the necessary information could be returned in one call. These additional values could be tightly packed into unused space in the Avastar struct as they each only require a single byte of storage.

3.  Each of 12 traits in the loop makes 2 external calls.

- [L371](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L371): `traitId = teleporterContract.getTraitIdByGenerationGeneAndVariation(_generation, Gene(slot), uint8(variation))`
- [L401](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L401) `teleporterContract.getTraitNameById(traitId)`.

AvastarTeleporter could instead have a single function that returns both the `name` and `traitId`, accessed by generation, gene, and variation.

### N15: Unnecessary Validation

##### Description

```solidity
require(msg.sender != address(0));
```

This validation is unnecessary as `msg.sender` can never be address(0). This issue is present in AvastarPrimeMinter on [L152](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarPrimeMinter.sol#L152), [L164](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarPrimeMinter.sol#L164), and [L176](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarPrimeMinter.sol#L176)

##### Recommendation

Validating the same inputs in both `purchasePrime()` and `mintPrime()` is redundant. Consider making all new mint calls flow through a single path to reduce the overhead of revalidation

##### Status

Mostly addressed. `require(msg.sender != address(0))` has been [removed](https://github.com/Dapp-Wizards/Avastars-Contracts/commit/298e38ad4c169b0fa1142fec5938c90450cc402b#diff-b7b364011b2d057b016161e4d21a0a98). Some of the duplicated validation between `purchasePrime()` and `mintPrime()` has been removed. There is still an opportunity to funnel all minting through the PrimeMinter, even the promos. This would eliminate the need for code duplication in both contracts.

### N16: Redundant and/or Duplicated Code

##### Description

1. The variable `metadataContractAddress` on [L37](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarTeleporter.sol#L37) can be declared public and automatically produce a getter function. This would remove the need for the redundant `getMetadataContractAddress()` on [L71-L75](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarTeleporter.sol#L71-L75) function.
2. Many functions repeatedly downcast the same inputs rather than storing them once as variables in local memory. If type conversion is needed more than once during function execution favour storing a local variable. Repeated the down-casting adds gas overhead and reduces code readability.

##### Status

Addressed in some cases. This is a very minor optimization that could be implemented in functions throughout the code base.

### N17: Benign Reentrancy in safeTransferFrom()

##### Description

It's possible for the external call in the `safeTransferFrom()` function in the OpenZeppelin [ERC-721 contract](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/ERC721.sol) ERC-721 to trigger reentrancy in a specific edge case. An external call is made on [L344](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/ERC721.sol#L334) of the `_checkOnERC721Received()` function.

This is an unlikely edge case that would require a that malicious attacker to craft a function signature collision with `bytes4(keccak256("onERC721Received(address,address,uint256,bytes)"))`. The signature of this function is `0x150b7a02`. An example of a valid colliding function signature is `bytes4(keccak256("$$$_10284c80_$$$()"))`. If a contract with the later function is called with 0 ether value, it executes as a direct method `CALL` and can pass an arbitrary amount of gas. It does not execute as a `STATICCALL`, which would limit the gas passed to external caller. If the malicious function returns `0x150b7a02` at the end of execution it can execute arbitrary logic, including reentrancy.

##### Status

Acknowledged. The risks of modifying dependencies and/or breaking established standards are likely greater than any risks from this hypothetical edge case.

### N18: TraitsUsed() Event Emits the Full Array in All Cases

##### Description

The function `useTraits()` on [L119-L158](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc/contracts/AvastarTeleporter.sol#L119-L158) in AvastarTeleporter requires at least one trait to change states in order for the function to reach the `TraitsUsed()` event. However, this function emits the full `prime.replicated` array without indicating which entries changed states.

##### Recommendation

I recommend creating a new array in memory and tracking the traits used by index. The event can then emit a smaller set of traits with states that have changed.

##### Status

Acknowledged. This is expected behaviour as it preserves the correct order of traits provided as input. Accessing or parsing by index is out of scope for the goals of this feature.

### N19: Inconsistencies With Official Solidity Style Recommendations

##### Description

The style guide recommends limiting line length to 79 or 99 characters. It also recommends indenting modifiers and visibility on long function names. For example:

```solidity
function extendTraitArt(uint256 _traitId, string calldata _svg)
    external
    onlySysAdmin()
    whenNotPaused()
    onlyBeforeProd(traits[_traitId].generation)
{
    require(_traitId < traits.length);
    string memory art = strConcat(traits[_traitId].svg, _svg);
    traits[_traitId].svg = art;
    emit TraitArtExtended(_traitId);
}
```

##### Status

Acknowledged.

### N20: Comment Refers to Incorrect Event

##### Description

A comment on [L48](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/1ea95a92d0859610533f40acd1df68a91353c0ea/contracts/AvastarTeleporter.sol#L48) in AvastarTeleporter incorrectly refers to the `TeleporterContractSet()` event being emitted when the function emits the event `MetadataContractAddressSet()`.

##### Status

[Addressed](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarTeleporter.sol#L48).

### N21: Hard-Coded Limited in for Loop Is Not Future-Proof

##### Description

On [L249](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/TraitFactory.sol#L249) in the `assembleArtwork()` function in TraitFactory and on [L362](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol#L362) in `assembleTraitMetadata()` function in AvastarMetadata both hardcode the upper limit of a for loop as `Gene.HAIR_STYLE`. There is nothing indicating that this will always be the final value in the Gene enum. This could easily be overlooked in future updates to the contracts.

```solidity
for (uint8 slot = 0; slot <= uint8(Gene.HAIR_STYLE); slot++){...}
```

##### Status

Acknowledged.

### N22: Unnecessary Inheritance

No contract in the AvastarMetadata inheritance structure uses the SafeMath Library. It is inherited in AccessControl on [L13-L14](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AccessControl.sol#L13-L14). However, neither AccessControl nor any of the contracts which inherit it use the library.

```solidity
using SafeMath for uint256;
using SafeMath for uint16;
```

PrimeMinter uses SafeMath. However, it should declare it at the appropriate point and with the appropriate specificity for its use. A better location for declaring the library is at the start of AvastarPrimeMinter (for `uint256` only). Several OpenZeppelin dependencies in AvastarTeleporter reference and use SafeMath. However, none of the core contracts use it. In all cases, the SafeMath declarations can be removed from AccessControl.

##### Status

This is a new informational note submitted after the full audit report and thus was not addressed.

## Appendix

### A01: Smart Contracts Reviewed

##### Core Contracts

The following core Avastars contracts were included within the scope of the audit review:

- [AccessControl.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AccessControl.sol)
- [AvastarBase.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarBase.sol)
- [AvastarFactory.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarFactory.sol)
- [AvastarMetadata.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarMetadata.sol)
- [AvastarPrimeMinter.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarPrimeMinter.sol)
- [AvastarState.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarState.sol)
- [AvastarTeleporter.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarTeleporter.sol)
- [AvastarTypes.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarTypes.sol)
- [IAvastarMetadata.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/IAvastarMetadata.sol)
- [IAvastarTeleporter.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/AvastarBase.solhttps://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/IAvastarTeleporter.sol)
- [PrimeFactory.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/PrimeFactory.sol)
- [ReplicantFactory.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/ReplicantFactory.sol)
- [TraitFactory.sol](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/contracts/TraitFactory.sol)

##### OpenZeppelin v2.4.0 Dependencies

The following contracts, interfaces, and libraries were included within the scope of the audit review:

- [Roles.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/access/Roles.sol)
- [Counters.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/drafts/Counters.sol)
- [Context.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/GSN/Context.sol)
- [ERC125.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/introspection/ERC165.sol)
- [IERC165.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/introspection/IERC165.sol)
- [SafeMath.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/math/SafeMath.sol)
- [ERC721.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/ERC721.sol)
- [ERC721Metadata.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/ERC721Metadata.sol)
- [ERC721Full.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/ERC721Full.sol)
- [ERC721Enumerable.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/ERC721Enumerable.sol)
- [IERC721.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/IERC721.sol)
- [IERC721Metadata.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/IERC721Metadata.sol)
- [IERC721Full.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/IERC721Full.sol)
- [IERC721Enumerable.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/IERC721Enumerable.sol)
- [IERC721Receiver.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/token/ERC721/IERC721Receiver.sol)
- [Address.sol](https://github.com/OpenZeppelin/openzeppelin-contracts/blob/cdf655f770cf8412fbd4d6aef3c55194a1233ef1/contracts/utils/Address.sol)

##### Additional Reference Material

The following material was referenced throughout the audit process, though not specifically included within the scope of the audit:

- [Avastars-Contracts GitHub repo](https://github.com/Dapp-Wizards/Avastars-Contracts/tree/b2ac9159a034c27b3ccad98fa806af08be37a842/)
- [Truffle project files](https://github.com/Dapp-Wizards/Avastars-Contracts/blob/b2ac9159a034c27b3ccad98fa806af08be37a842/truffle.js)
- [Unit tests](https://github.com/Dapp-Wizards/Avastars-Contracts/tree/b2ac9159a034c27b3ccad98fa806af08be37a842/test)
- Project documentation at [dapp-wizards.github.io](https://dapp-wizards.github.io/Avastars-Contracts)
- Deployment scripts, utilities, and helper contracts
- Code comments
- Discussions with the Avastars team

##### Not Available / Out of Scope

The following items are explicitly out of scope of the audit

- Off-chain hash generation, including random number generation
- Minting management system
- Key management system for permissioned accounts
- Pricing system
- AvastarsReplicantMinter smart contract

### A02: Test Coverage

This test coverage represents the unit test coverage as of the [b8220ee](https://github.com/Dapp-Wizards/Avastars-Contracts/tree/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc) commit. Test coverage has increased as development continued. The test coverage report was generated with [solidity-coverage](https://github.com/sc-forks/solidity-coverage).

| File                   | % Statements | % Branches | % Functions | % Lines |
| :--------------------- | :----------- | :--------- | :---------- | :------ |
| AccessControl.sol      | 100          | 91.67      | 100         | 100     |
| AvastarBase.sol        | 100          | 100        | 100         | 100     |
| AvastarFactory.sol     | 100          | 83.33      | 100         | 100     |
| AvastarMetadata.sol    | 98.57        | 88         | 100         | 98.43   |
| AvastarPrimeMinter.sol | 100          | 55         | 100         | 100     |
| AvastarState.sol       | 100          | 100        | 100         | 100     |
| AvastarTeleporter.sol  | 100          | 75         | 100         | 100     |
| AvastarTypes.sol       | 100          | 100        | 100         | 100     |
| IAvastarMetadata.sol   | 100          | 100        | 100         | 100     |
| IAvastarTeleporter.sol | 100          | 100        | 100         | 100     |
| PrimeFactory.sol       | 100          | 59.09      | 100         | 100     |
| ReplicantFactory.sol   | 100          | 57.14      | 100         | 100     |
| TraitFactory.sol       | 100          | 63.64      | 100         | 100     |
| Context.sol            | 0            | 100        | 33.33       | 0       |
| Roles.sol              | 66.67        | 33.33      | 66.67       | 66.67   |
| Counters.sol           | 33.33        | 100        | 33.33       | 33.33   |
| ERC165.sol             | 75           | 50         | 66.67       | 75      |
| SafeMath.sol           | 36.84        | 16.67      | 37.5        | 36.84   |
| ERC721.sol             | 19.64        | 8.33       | 19.05       | 19.64   |
| ERC721Enumerable.sol   | 27.27        | 0          | 41.67       | 25.71   |
| ERC721Full.sol         | 100          | 100        | 100         | 100     |
| ERC721Metadata.sol     | 27.27        | 0          | 16.67       | 25      |
| IERC721.sol            | 100          | 100        | 100         | 100     |
| IERC721Enumerable.sol  | 100          | 100        | 100         | 100     |
| IERC721Full.sol        | 100          | 100        | 100         | 100     |
| IERC721Metadata.sol    | 100          | 100        | 100         | 100     |
| IERC721Receiver.sol    | 100          | 100        | 100         | 100     |
| Address.sol            | 0            | 0          | 0           | 0       |

### A03: Inheritance and Dependencies

_\*OpenZeppelin Dependencies_

##### AvastarMetadata (deployed at [0xE895B49900636F0330c3dc2Fb6FA09d234622E8e](https://etherscan.io/address/0xe895b49900636f0330c3dc2fb6fa09d234622e8e#code))

- IAvastarTeleporter
  - AvastarTypes
- AvastarBase
- AccessControl
  - Roles\*
  - SafeMath\*

##### AvastarPrimeMinter (deployed at [0xE31763aaD9294f073DDF18B36503ed037ae5e737](https://etherscan.io/address/0xe31763aad9294f073ddf18b36503ed037ae5e737#code))

- IAvastarTeleporter
  - AvastarTypes
- AvastarBase
- AccessControl
  - Roles\*
  - SafeMath\*

##### AvastarTeleporter (deployed at [0xF3E778F839934fC819cFA1040AabaCeCBA01e049](https://etherscan.io/address/0xf3e778f839934fc819cfa1040aabacecba01e049#code))

- IAvastarMetadata
- ReplicantFactory
  - PrimeFactory
    - AvastarFactory
      - TraitFactory
        - AvastarState
          - AvastarBase
          - AvastarTypes
          - AccessControl
            - Roles\*
          - ERC721Full\*
            - ERC721Enumerable\*
              - IERC721Enumerable\*
            - ERC721Metadata\*
              - IERC721Metadata\*
            - ERC721\*
              - IERC721Receiver\*
              - Context\*
              - ERC165\*
                - IERC721\*
                - IERC165\*
              - Address\*
              - Counters\*
              - SafeMath\*

### A04: Risk Rating Model

This audit uses the OWASP risk rating model to evaluate the severity of potential issues based on their likelihood of occurring and their potential impact.

<img src={risk_model} width="1200" alt="risk_model" />

##### Critical

Directly exploitable security threats that should be fixed immediately. Examples include:

- Theft or permanent freezing of ether or ERC-721 tokens
- Unauthorized minting of ERC-721 tokens

##### High

Serious issues that may be indirectly exploitable or exploitable under specific circumstances. These issues should be addressed as soon as possible. Examples include:

- Limited or situational theft or freezing of funds or tokens
- Unplanned execution states, unauthorized state changes, and other unexpected contract behaviour with a significant impact on funds or tokens
- Denial of service or other significant disruptions to normal operation

##### Medium

Moderate severity issues or issues that may only be exploitable as edge cases. These issues should be addressed. Examples include:

- Unplanned execution states, unauthorized state changes, and other unexpected contract behaviour with moderate or indirect impact on security
- Potentially dangerous privileges and permissions
- Higher-impact issues exploitable only under specific edge case conditions

##### Low

Low severity security issues with minor impact. This section may also include substantial optimization or other recommendations. In some cases, these issues may represent the auditors subjective attitude about best practices, design decisions, and/or contract architecture.

Examples include:

- Unplanned execution states, unauthorized state changes, and other unexpected contract behaviour with limited or no impact to security
- Deviations from smart contract development or Solidity best practices
- Unused or redundant code

##### Note

Minor recommendations with no direct security implementations. These include gas optimizations and style notes.

### A05: Version History

| Date     | Description                                 | Version | Commit                                                                                                        |
| :------- | :------------------------------------------ | :------ | :------------------------------------------------------------------------------------------------------------ |
| 05/24/20 | Avastars Smart Contract Audit Public Report | 0.3.0   | N/A                                                                                                           |
| 05/02/20 | Post-Audit Follow Up Report                 | 0.2.0   | [b2ac915](https://github.com/Dapp-Wizards/Avastars-Contracts/commit/b2ac9159a034c27b3ccad98fa806af08be37a842) |
| 28/01/20 | Avastars Smart Contract Audit Full Report   | 0.1.0   | [1ea95a9](https://github.com/Dapp-Wizards/Avastars-Contracts/commit/1ea95a92d0859610533f40acd1df68a91353c0ea) |
| 12/01/20 | Preliminary Assessment                      | N/A     | [b8220ee](https://github.com/Dapp-Wizards/Avastars-Contracts/commit/b8220ee9335167fd3e5d6c5691b20a3a4bb2a3dc) |
| 09/15/19 | On-Chain Storage Cost Feasibility Report    | N/A     | N/A                                                                                                           |

### A06: Onchain Storage Cost Recommendations

The following comments were part of an initial feasibility analysis completed 09/15/19. It investigates the viability of storing large amounts of data on-chain. Several example svg images were provided by the Avastars team to conduct this research.

1. Storing unoptimized full svg data, especially with xml tags, is expensive. In some cases, complex images may even exceed the Ethereum block size limit.
2. Optimized code run through svgo reduces this cost by ~30%.
3. Tightly packed and pruned storage of the values reduces the base gas cost by ~85%.
4. The example svgs often contain redundant data, blank attributes, unnecessary complexity (polylines, patterns, etc), and use design techniques that exponentially increase the storage footprint (i.e., clipping masks).
5. It is possible to store critical values in tightly-packed structs or other efficient data structures. Repeated values can be stored as constants. The original image can still be reconstructed completely without losing information. The tradeoff is increased smart contract code and image reconstruction complexity.
6. In my honest opinion, attempting to store the full xml-tagged svgs, particularly poorly optimized svgs, is just a bad fit for the current capabilities of smart contracts. It's a square peg in a round hole. If the project was just beginning, my advice would be: consider the most restrictive element of the project first and design to those constraints.
7. If having the whole file on-chain is truly important, consider alternative optimization software, compression software, and establish strict design processes for the artists that produce much smaller code footprints.
8. There may be a point where saving some gas is not worth the cost of redeveloping large sections of code base.

### Disclaimer

This audit incorporated the latest security patterns, best practices, and analysis tools. However, it does not provide a guarantee for the security of the code, the absence of future bugs, or the completeness or correctness of its findings. Protocol changes, an adversarial production environment, and the experimental nature of smart contract technology present ongoing risk to the security of this, or any, application on the Ethereum blockchain.

## Table of Contents

- [Introduction](#introduction)
  - [Objectives](#objectives)
  - [Scope and Timeline](#scope-and-timeline)
- [Project Overview](#project-overview)
  - [Contract Architecture](#contract-architecture)
  - [Token Design](#token-design)
  - [Trust Model, Access, and Authority](#trust-model-access-and-authority)
  - [Documentation, Code Quality, and Testing](#documentation-code-quality-and-testing)
  - [Security Considerations](#security-considerations)
- [Key Observations](#key-observations)
  - [Summary of Issues](#summary-of-issues)
  - [General assessment](#general-assessment)
- [Critical Severity Issues](#critical-severity)
- [High Severity Issues](#high-severity)
  - [H01: Replicated Traits Not Updated in Storage](#h01-replicated-traits-not-updated-in-storage)
  - [H02: Prime Supply Can Exceed the Defined Supply Limit](#h02-prime-supply-can-exceed-the-defined-supply-limit)
  - [H03: Unauthorized Access to Prime Array With Replicant Tokens and Vice Versa](#h03-unauthorized-access-to-prime-array-with-replicant-tokens-and-vice-versa)
  - [H04: Unchecked Return Call Could Lead to Incorrect Debiting of User Balances](#h04-unchecked-return-call-could-lead-to-incorrect-debiting-of-user-balances)
- [Medium Severity Issues](#medium-severity)
  - [M01: Denial of Service and Griefing During Minting](#m01-denial-of-service-and-griefing-during-minting)
  - [M02: Admin Overwrite Permissions](#m02-admin-overwrite-permissions)
  - [M03: Irreversible Permissions and Other Access Control Issues](#m03-irreversible-permissions-and-other-access-control-issues)
  - [M04: Unchecked Array Length Creates uint8 Overflow in for Loop](#m04-unchecked-array-length-creates-uint8-overflow-in-for-loop)
  - [M05: Dynamic Array Used for Fixed Length Property](#m05-dynamic-array-used-for-fixed-length-property)
  - [M06: Unchecked Minter Privileges Require Extensive User Trust During Purchases](#m06-unchecked-minter-privileges-require-extensive-user-trust-during-purchases)
  - [M07: Contract Does Not Enforce Supply Limit for Replicants](#m07-contract-does-not-enforce-supply-limit-for-replicants)
  - [M08: Open Access to Uninitialized Storage Pointers](#m08-open-access-to-uninitialized-storage-pointers)
- [Low Severity Issues](#low-severity)
  - [L01: Out of Bounds Enum Inputs Can Trigger Invalid Opcode](#l01-out-of-bounds-enum-inputs-can-trigger-invalid-opcode)
  - [L02: State Access in Event Emitted After External Call](#l02-state-access-in-event-emitted-after-external-call)
  - [L03: Trait Hashes Rely on External Validation](#l03-trait-hashes-rely-on-external-validation)
  - [L04: Duplicate Values Possible in Series Array](#l04-duplicate-values-possible-in-series-array)
  - [L05: traitHandlerByPrimeTokenId Gives a Handler Access to All of a User's Unused Traits](#l05-traithandlerbyprimetokenid-gives-a-handler-access-to-all-of-a-users-unused-traits)
  - [L06: upgradeContract() Does Not Check for Null Address](#l06-upgradecontract-does-not-check-for-null-address)
  - [L07: isAvastarTeleporter() and isAvastarMetadata() Checks Are Insufficient](#l07-isavastarteleporter-and-isavastarmetadata-checks-are-insufficient)
  - [L08: Tightly Packing Traits Struct Will Save Gas](#l08-tightly-packing-traits-struct-will-save-gas)
  - [L09: setAttribution() Strings Can Be Set to Null](#l09-setattribution-strings-can-be-set-to-null)
  - [L10: TraitAccessApproved() Event Does Not Necessarily Reflect State Changes](#l10-traitaccessapproved-event-does-not-necessarily-reflect-state-changes)
  - [L11: Functions With Unnecessarily Permissive Visibility](#l11-functions-with-unnecessarily-permissive-visibility)
  - [L12: Limited Unit Test Coverage of Token Dependencies and Certain Branches of the Core Contracts](#l12-limited-unit-test-coverage-of-token-dependencies-and-certain-branches-of-the-core-contracts)
  - [L13: Default Truffle Project Settings Targets Outdated EVM Version](#l13-default-truffle-project-settings-targets-outdated-evm-version)
  - [L14: Unnecessary Duplication of Avastar Storage](#l14-unnecessary-duplication-of-avastar-storage)
  - [L15: Inconsistent Use of uint Alias](#l15-inconsistent-use-of-uint-alias)
  - [L16: AvastarReplicantMinter Contract Not Available](#l16-avastarreplicantminter-contract-not-available)
- [Note / Informational Issues](#note)
  - [N01: Floating Pragmas](#n01-floating-pragmas)
  - [N02: Unused Library Method With External Call](#n02-unused-library-method-with-external-call)
  - [N03: Potentially Unsafe Use of abi.encodePacked() if Hashed in the Future](#n03-potentially-unsafe-use-of-abiencodepacked-if-hashed-in-the-future)
  - [N04: assembleArtwork() Relies on Exponentiation of Mixed Uint Types](#n04-assembleartwork-relies-on-exponentiation-of-mixed-uint-types)
  - [N05: AvastarPrimeMinter Should Set AvastarTeleporter Contract in Constructor](#n05-avastarprimeminter-should-set-avastar-teleporter-contract-in-constructor)
  - [N06: Set Short Circuits With Mostly Likely Case First](#n06-set-short-circuits-with-mostly-likely-case-first)
  - [N07: State Variable Initialized With Default Value](#n07-state-variable-initialized-with-default-value)
  - [N08: Test Coverage Treats Invalid Execution States as Passing Conditions](#n08-test-coverage-treats-invalid-execution-states-as-passing-conditions)
  - [N09: Event Parameters Are Not Indexed](#n09-event-parameters-are-not-indexed)
  - [N10: Empty Events Are Emitted](#n10-empty-events-are-emitted)
  - [N11: Unnecessary Casting to Own Type](#n11-unnecessary-casting-to-own-type)
  - [N12: Unattributed Use of an External Dependency](#n12-unattributed-use-of-an-external-dependency)
  - [N13: Variable Shadowing](#n13-variable-shadowing)
  - [N14: External Calls in Loops](#n14-external-calls-in-loops)
  - [N15: Unnecessary Validation](#n15-unnecessary-validation)
  - [N16: Redundant and/or Duplicated Code](#n16-redundant-andor-duplicated-code)
  - [N17: Benign Reentrancy in safeTransferFrom()](#n17-benign-reentrancy-in-safetransferfrom)
  - [N18: TraitsUsed() Event Emits the Full Array in All Cases](#n18-traitsused-event-emits-the-full-array-in-all-cases)
  - [N19: Inconsistencies With Official Solidity Style Recommendations](#n19-inconsistencies-with-official-solidity-style-recommendations)
  - [N20: Comment Refers to Incorrect Event](#n20-comment-refers-to-incorrect-event)
  - [N21: Hard-Coded Limited in for Loop Is Not Future-Proof](#n21-hard-coded-limited-in-for-loop-is-not-future-proof)
  - [N22: Unnecessary Inheritance](#n22-unnecessary-inheritance)
- [Appendix](#appendix)
  - [A01: Smart Contracts Reviewed](#a01-smart-contracts-reviewed)
  - [A02: Test Coverage](#a02-test-coverage)
  - [A03: Inheritance and Dependencies](#a03-inheritance-and-dependencies)
  - [A04: Risk Rating Model](#a04-risk-rating-model)
  - [A05: Version History](#a05-version-history)
  - [A06: Onchain Storage Cost Recommendations](#a06-onchain-storage-cost-recommendations)
  - [A07: Disclaimer](#a07-disclaimer)
- [Table of Contents](#table-of-contents)

<svg>
  <defs>
    <filter id="id-of-your-filter">
      <feComponentTransfer in="SourceGraphic" result="A">
        <feFuncR type="table" tableValues="0 0.7 0 0" />
        <feFuncG type="table" tableValues="0 0.7 0 0" />
        <feFuncB type="table" tableValues="0 0.7 0 0" />
      </feComponentTransfer>
    </filter>
  </defs>
</svg>
